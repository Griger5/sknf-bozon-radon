# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L4VyUjy8MR9lp6K1ejXPOdqLVMM0SR7A
"""

import folium
from folium.plugins import TagFilterButton
import pandas as pd
import numpy as np
import branca.colormap as cmp
import matplotlib.pyplot as plt
import matplotlib.tri as tri
import base64
from io import BytesIO
from folium import Element, FeatureGroup, LayerControl, raster_layers
import webbrowser



def plot_to_base64():
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    image_base64 = base64.b64encode(buf.read()).decode('utf-8')
    buf.close()
    plt.close()
    return image_base64



def generate_statistics(coords_df, detector_df, categories_df):
    stats_html = """
    <style>
        .stat-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 10px 0; }
        .stat-card { border: 1px solid #ccc; padding: 10px; border-radius: 5px; background: white; }
        h2 { color: #2c3e50; }
        h3 { color: #34495e; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
    </style>
    <h2>Opcje statystyczne</h2>
    """


    densities = []
    for i in range(len(coords_df)):
        try:
            detector_id = str(coords_df.iloc[i]["Nr detektora"]).replace(" ", "")
            if detector_id == "HA4116": continue
            density_value = detector_df.loc[detector_id, "Stężenie radonu"]
            if hasattr(density_value, 'item'): density_value = density_value.item()
            densities.append(float(density_value))
        except: continue

    if densities:
        plt.figure(figsize=(10, 6))
        plt.hist(densities, bins=20, alpha=0.7, color='skyblue', edgecolor='black')
        plt.title('Rozkład stężenia radonu')
        plt.xlabel('Stężenie [Bq/m³]')
        plt.ylabel('Liczba detektorów')
        plt.grid(True, alpha=0.3)
        hist_all = plot_to_base64()

        stats_html += f"""
        <div class="stat-section">
            <h3>Statystyki ogólne</h3>
            <p><b>Średnia:</b> {np.mean(densities):.2f} ± {np.std(densities):.2f}</p>
            <p><b>Mediana:</b> {np.median(densities):.2f}</p>
            <p><b>Min-Max:</b> {np.min(densities):.2f} - {np.max(densities):.2f}</p>
            <img src="data:image/png;base64,{hist_all}" style="width:100%; max-width:600px;">
        </div>
        """


    building_stats = {}
    for building_type in ["kamienica", "blok", "wolnostojący", "szeregowy"]:
        b_densities = []
        for i in range(len(coords_df)):
            try:
                building = str(coords_df.iloc[i]["Typ budynku"]).removesuffix("/blok")
                if building == building_type:
                    detector_id = str(coords_df.iloc[i]["Nr detektora"]).replace(" ", "")
                    if detector_id == "HA4116": continue
                    val = detector_df.loc[detector_id, "Stężenie radonu"]
                    if hasattr(val, 'item'): val = val.item()
                    b_densities.append(float(val))
            except: continue

        if b_densities:
            building_stats[building_type] = {
                'mean': np.mean(b_densities), 'std': np.std(b_densities),
                'count': len(b_densities), 'median': np.median(b_densities),
                'data': b_densities, 'min': np.min(b_densities), 'max': np.max(b_densities)
            }

    if building_stats:
        plt.figure(figsize=(12, 6))
        box_data = [d['data'] for d in building_stats.values()]
        box_labels = [f"{k}\n(n={v['count']})" for k, v in building_stats.items()]
        plt.boxplot(box_data, tick_labels=box_labels)
        plt.title('Stężenie radonu wg typu budynku')
        plt.grid(True, alpha=0.3)
        boxplot = plot_to_base64()

        stats_html += f"""
        <div class="stat-section"><h3>Typy budynków</h3><div class="grid-container">"""
        for k, v in building_stats.items():
            stats_html += f"<div class='stat-card'><b>{k}</b><br>Śr: {v['mean']:.1f}<br>Med: {v['median']:.1f}</div>"
        stats_html += f"""</div><img src="data:image/png;base64,{boxplot}" style="width:100%; max-width:700px;"></div>"""


    age_stats = {}
    age_cats = ["<1900", "1900-1920", "1920-1940", "1940-1960", "1960-1980", "1980-2000", "2000-2020", "2020-2040"]

    for cat in age_cats:
        a_densities = []
        for i in range(len(coords_df)):
            try:
                rok = str(coords_df.iloc[i]["Rok Budowy"]).replace("? ", "")
                calc_age = "?"
                try:
                    r_int = int(float(rok))
                    if r_int < 1900: calc_age = "<1900"
                    else:
                        for v in range(1900, 2040, 20):
                            if v <= r_int < v+20: calc_age = f"{v}-{v+20}"; break
                except: pass

                if calc_age == cat:
                    d_id = str(coords_df.iloc[i]["Nr detektora"]).replace(" ", "")
                    if d_id == "HA4116": continue
                    val = detector_df.loc[d_id, "Stężenie radonu"]
                    if hasattr(val, 'item'): val = val.item()
                    a_densities.append(float(val))
            except: continue

        if a_densities:
            age_stats[cat] = {'mean': np.mean(a_densities), 'std': np.std(a_densities), 'count': len(a_densities)}

    if age_stats:
        plt.figure(figsize=(12, 6))
        lbls = list(age_stats.keys())
        means = [age_stats[k]['mean'] for k in lbls]
        stds = [age_stats[k]['std'] for k in lbls]
        plt.bar(lbls, means, yerr=stds, capsize=5, alpha=0.7, color='lightcoral')
        plt.xticks(rotation=45)
        plt.title('Średnie stężenie wg wieku')
        plt.grid(True, alpha=0.3)
        age_chart = plot_to_base64()
        stats_html += f"""<div class="stat-section"><h3>Wiek budynku</h3><img src="data:image/png;base64,{age_chart}" style="width:100%; max-width:800px;"></div>"""

    return stats_html

#TRIANGULACJA Z MASKOWANIEM

def add_triangulation_layer(m, coords_df, detector_df, vmin, vmax):
    print("Generowanie interpolacji...")


    data = []
    for i in range(len(coords_df)):
        try:
            raw_id = str(coords_df.iloc[i]["Nr detektora"])
            clean_id = raw_id.replace(" ", "")
            if clean_id == "HA4116": continue

            val = detector_df.loc[clean_id, "Stężenie radonu"]
            if isinstance(val, pd.Series): val = val.iloc[0]
            val = float(val)

            lat = coords_df.iloc[i]["Latitude"]
            lon = coords_df.iloc[i]["Longitude"]

            if not (np.isnan(lat) or np.isnan(lon) or np.isnan(val)):
                data.append([lon, lat, val])
        except: continue

    data_arr = np.array(data)
    if len(data_arr) < 3: return

    x = data_arr[:, 0]
    y = data_arr[:, 1]
    z = data_arr[:, 2]


    triang = tri.Triangulation(x, y)


    threshold = 0.12
    mask = []
    x_tri = x[triang.triangles]
    y_tri = y[triang.triangles]

    for i in range(len(triang.triangles)):
        xs = x_tri[i]; ys = y_tri[i]

        d1 = np.sqrt((xs[0]-xs[1])**2 + (ys[0]-ys[1])**2)
        d2 = np.sqrt((xs[1]-xs[2])**2 + (ys[1]-ys[2])**2)
        d3 = np.sqrt((xs[2]-xs[0])**2 + (ys[2]-ys[0])**2)


        if d1 > threshold or d2 > threshold or d3 > threshold:
            mask.append(True)
        else:
            mask.append(False)
    triang.set_mask(mask)


    plt.ioff()
    margin = 0.02
    xlim = [min(x)-margin, max(x)+margin]
    ylim = [min(y)-margin, max(y)+margin]

    fig, ax = plt.subplots(figsize=(12, 12))
    ax.set_xlim(xlim); ax.set_ylim(ylim); ax.axis('off')

    # levels od vmin do vmax
    levels = np.linspace(vmin, vmax, 40)

    ax.tricontourf(triang, z, levels=levels, cmap='RdYlBu_r', alpha=0.7, extend='both')

    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0, transparent=True)
    buf.seek(0)
    img_str = "data:image/png;base64," + base64.b64encode(buf.read()).decode('utf-8')
    plt.close()


    interp_fg = FeatureGroup(name="Interpolacja (Triangulacja)", show=True)
    raster_layers.ImageOverlay(
        image=img_str,
        bounds=[[ylim[0], xlim[0]], [ylim[1], xlim[1]]],
        opacity=0.75,
        interactive=False,
        zindex=1
    ).add_to(interp_fg)
    interp_fg.add_to(m)



m = folium.Map([50.06, 19.94], zoom_start=10, tiles="OpenStreetMap")


try:
    main_excel = pd.ExcelFile("DETEKTORY_DANE_18_10_2025.xlsx")
    coords_df = pd.read_excel(main_excel, "Sheet1").dropna(subset=["Latitude", "Longitude"]).reset_index(drop=True)
    detector_df = pd.read_excel("wyniki_JK.xlsx")
    detector_df["Detector ID"] = detector_df["Detector ID"].astype(str).str.replace(" ", "")
    detector_df = detector_df.set_index("Detector ID")
    detector_df.columns = detector_df.columns.str.strip()

    if "Track density" in detector_df.columns and "Stężenie radonu" not in detector_df.columns:
        detector_df["Stężenie radonu"] = detector_df["Track density"]


    all_values = []
    for i in range(len(coords_df)):
        try:
            did = str(coords_df.iloc[i]["Nr detektora"]).replace(" ", "")
            if did == "HA4116": continue
            v = float(detector_df.loc[did, "Stężenie radonu"])
            all_values.append(v)
        except: pass

    if all_values:
        global_min = min(all_values)
        global_max = max(all_values)
    else:
        global_min, global_max = 0, 200

    print(f"Skala dynamiczna: {global_min:.1f} - {global_max:.1f} Bq/m³")

except Exception as e:
    print(f"Błąd ładowania danych: {e}")
    exit()


categories_df = pd.DataFrame(index=coords_df.index)
age_categories = ["<1900", "1900-1920", "1920-1940", "1940-1960", "1960-1980", "1980-2000", "2000-2020", "2020-2040"]
building_categories = ["blok", "kamienica", "szeregowy", "wolnostojący"]
material_categories = ["cegła", "beton", "pustak", "drewno", "kamień", "styropian", "wylewka", "wielka płyta"]
connections_categories = ["woda", "gaz", "kanalizacja", "wentylacja", "CO", "klimatyzacja"]
all_categories = [*age_categories, *building_categories, *material_categories, *connections_categories]


for col in all_categories: categories_df[col] = 0
if "Materiał Budowlany" in coords_df.columns:
    txt = coords_df["Materiał Budowlany"].fillna("").astype(str).str.lower()
    for mat in material_categories: categories_df[mat] = txt.str.contains(mat, regex=False).astype(int)
for conn in connections_categories:
    for c in coords_df.columns:
        if str(c).lower().strip() == conn.lower():
            categories_df[conn] = coords_df[c].fillna("").astype(str).str.lower().apply(lambda x: 1 if "tak" in x or "1" in x else 0)


colormap = cmp.LinearColormap(
    colors=['blue', 'cyan', 'green', 'yellow', 'orange', 'red'],
    vmin=global_min,
    vmax=global_max,
    caption=f"Stężenie radonu [Bq/m³] (min: {global_min:.0f}, max: {global_max:.0f})"
)
colormap.add_to(m)


def get_marker_color(val):
    if val == "?": return "gray"

    norm = (val - global_min) / (global_max - global_min) if global_max > global_min else 0.5
    if norm < 0.2: return "blue"
    elif norm < 0.4: return "green"
    elif norm < 0.6: return "orange"
    elif norm < 0.8: return "red"
    else: return "black"


stats_content = generate_statistics(coords_df, detector_df, categories_df)
button_html = f'''
<div style="position: fixed; top: 50%; right: 10px; transform: translateY(-50%); z-index: 1000;">
    <button onclick="document.getElementById('statsModal').style.display='block'" style="
        background: #9b59b6; color: white; border: none; padding: 15px 10px;
        border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;
        writing-mode: vertical-rl; text-orientation: mixed; height: 150px; letter-spacing: 2px;">
        STATYSTYKI
    </button>
</div>
<div id="statsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; overflow: auto;">
    <div style="background: white; margin: 20px auto; padding: 20px; width: 95%; max-width: 1200px; border-radius: 10px;">
        <div style="text-align: right; margin-bottom: 15px; position: sticky; top:0; background: white;">
            <button onclick="document.getElementById('statsModal').style.display='none'" style="background: #e74c3c; color: white; border: none; padding: 8px 15px; border-radius: 5px;">✕ Zamknij</button>
        </div>
        {stats_content}
    </div>
</div>
'''
m.get_root().html.add_child(Element(button_html))

TagFilterButton(all_categories).add_to(m)


markers_fg = FeatureGroup(name="Punkty pomiarowe", show=True)

for i in range(len(coords_df)):
    raw_id = str(coords_df.iloc[i]["Nr detektora"])
    clean_id = raw_id.replace(" ", "")

    density, yearly = "?", "?"
    val_num = 0
    try:
        if clean_id != "HA4116":
            val = detector_df.loc[clean_id, "Stężenie radonu"]
            if isinstance(val, pd.Series): val = val.iloc[0]
            val_num = float(val)
            density = val_num

            val_y = detector_df.loc[clean_id, "a"]
            if isinstance(val_y, pd.Series): val_y = val_y.iloc[0]
            yearly = float(val_y)
    except: pass


    color = "gray"
    if density != "?":
        color = get_marker_color(val_num)


    building = str(coords_df.iloc[i]["Typ budynku"]).removesuffix("/blok")
    mats = [m for m in material_categories if categories_df.iloc[i][m]]
    conns = [c for c in connections_categories if categories_df.iloc[i][c]]

    age = "?"
    try:
        r = str(coords_df.iloc[i]["Rok Budowy"]).replace("? ", "")
        ri = int(float(r))
        if ri < 1900: age = "<1900"
        else:
            for v in range(1900, 2040, 20):
                if v <= ri < v+20: age = f"{v}-{v+20}"; break
    except: pass


    html = f"""
        <div style="font-family: Arial; font-size: 12px;">
            <h1 style="margin: 0 0 10px 0;">{raw_id}</h1>
            <h4 style="margin: 5px 0;">Dane pomiarowe:</h4>
            <p style="margin: 0;">
                <b>Stężenie radonu:</b> {density} [Bq/m³]<br/>
                <b>Średnioroczne:</b> {yearly} [Bq/m³]<br/>
                <b>Czas ekspozycji:</b> {coords_df.iloc[i]["Czas ekspozycji (dni)"]:.1f} dni<br/>
                <b>Data startu:</b> {coords_df.iloc[i]["Start data"]}<br/>
                <b>Data końca:</b> {coords_df.iloc[i]["Koniec data"]}
            </p>
            <h4 style="margin: 10px 0 5px 0;">Dane budynku:</h4>
            <p style="margin: 0;">
                <b>Rok budowy:</b> {coords_df.iloc[i]["Rok Budowy"]}<br/>
                <b>Typ:</b> {building}<br/>
                <b>Materiały:</b> {", ".join(mats) if mats else "-"}<br/>
                <b>Przyłącza:</b> {", ".join(conns) if conns else "-"}<br/>
                <br/>
                <i>Uwagi: {coords_df.iloc[i]["Uwagi"]}</i>
            </p>
        </div>
    """

    iframe = folium.IFrame(html=html, width=350, height=350)
    popup = folium.Popup(iframe, max_width=350)

    folium.Marker(
        location=[coords_df.iloc[i]["Latitude"], coords_df.iloc[i]["Longitude"]],
        popup=popup,
        icon=folium.Icon(color=color),
        tags=[building, age, *mats, *conns]
    ).add_to(markers_fg)

markers_fg.add_to(m)

# Interpolacja
add_triangulation_layer(m, coords_df, detector_df, global_min, global_max)

LayerControl(collapsed=False).add_to(m)
m.save("map.html")
print("Zapisano plik: map.html")
webbrowser.open(r"map.html")